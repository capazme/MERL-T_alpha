# Configurazione Writers per Pipeline Enrichment
# ===============================================
# Query Cypher e parametri per scrittura nel grafo.

# Schema version (per tracking migrazioni)
schema_version: "2.1"

# Configurazione generale
general:
  # Batch size per scrittura
  batch_size: 50

  # Timeout per query (secondi)
  query_timeout: 30

  # Retry su errore
  retry_count: 3
  retry_delay: 1.0  # secondi

# Query Cypher per creazione nodi
cypher_create:
  # Crea o merge ConcettoGiuridico
  concept: |
    MERGE (c:ConcettoGiuridico {node_id: $node_id})
    ON CREATE SET
      c.nome = $nome,
      c.nome_normalizzato = $nome_normalizzato,
      c.descrizione = $descrizione,
      c.ambito = $ambito,
      c.fonti = [$fonte],
      c.schema_version = $schema_version,
      c.created_at = timestamp()
    ON MATCH SET
      c.fonti = CASE
        WHEN $fonte IN c.fonti THEN c.fonti
        ELSE c.fonti + $fonte
      END,
      c.updated_at = timestamp(),
      c.descrizione = CASE
        WHEN size($descrizione) > size(coalesce(c.descrizione, ''))
        THEN $descrizione
        ELSE c.descrizione
      END
    RETURN c.node_id as node_id, c.fonti as fonti

  # Crea o merge PrincipioGiuridico
  principle: |
    MERGE (p:PrincipioGiuridico {node_id: $node_id})
    ON CREATE SET
      p.nome = $nome,
      p.nome_normalizzato = $nome_normalizzato,
      p.descrizione = $descrizione,
      p.livello = $livello,
      p.fonti = [$fonte],
      p.schema_version = $schema_version,
      p.created_at = datetime()
    ON MATCH SET
      p.fonti = CASE
        WHEN $fonte IN p.fonti THEN p.fonti
        ELSE p.fonti + $fonte
      END,
      p.updated_at = datetime()
    RETURN p.node_id as node_id, p.fonti as fonti

  # Crea o merge DefinizioneLegale
  definition: |
    MERGE (d:DefinizioneLegale {node_id: $node_id})
    ON CREATE SET
      d.nome = $nome,
      d.nome_normalizzato = $nome_normalizzato,
      d.descrizione = $descrizione,
      d.tipo_definizione = $tipo_definizione,
      d.fonti = [$fonte],
      d.schema_version = $schema_version,
      d.created_at = datetime()
    ON MATCH SET
      d.fonti = CASE
        WHEN $fonte IN d.fonti THEN d.fonti
        ELSE d.fonti + $fonte
      END,
      d.updated_at = datetime()
    RETURN d.node_id as node_id, d.fonti as fonti

  # Crea nodo Dottrina (ristrutturato)
  dottrina: |
    CREATE (d:Dottrina {
      node_id: $node_id,
      tipo: $tipo,
      testo: $testo,
      autore: $autore,
      fonte: $fonte,
      concetti_trattati: $concetti_trattati,
      principi_trattati: $principi_trattati,
      schema_version: $schema_version,
      created_at: datetime()
    })
    RETURN d.node_id as node_id

  # ─────────────────────────────────────────────────────────────────────────
  # SOGGETTI (priorità 2)
  # ─────────────────────────────────────────────────────────────────────────

  # Crea o merge SoggettoGiuridico
  soggetto: |
    MERGE (s:SoggettoGiuridico {node_id: $node_id})
    ON CREATE SET
      s.nome = $nome,
      s.nome_normalizzato = $nome_normalizzato,
      s.descrizione = $descrizione,
      s.tipo_soggetto = $tipo_soggetto,
      s.fonti = [$fonte],
      s.schema_version = $schema_version,
      s.created_at = datetime()
    ON MATCH SET
      s.fonti = CASE WHEN $fonte IN s.fonti THEN s.fonti ELSE s.fonti + $fonte END,
      s.updated_at = datetime()
    RETURN s.node_id as node_id, s.fonti as fonti

  # Crea o merge Ruolo
  ruolo: |
    MERGE (r:Ruolo {node_id: $node_id})
    ON CREATE SET
      r.nome = $nome,
      r.nome_normalizzato = $nome_normalizzato,
      r.descrizione = $descrizione,
      r.contesto = $contesto,
      r.fonti = [$fonte],
      r.schema_version = $schema_version,
      r.created_at = datetime()
    ON MATCH SET
      r.fonti = CASE WHEN $fonte IN r.fonti THEN r.fonti ELSE r.fonti + $fonte END,
      r.updated_at = datetime()
    RETURN r.node_id as node_id, r.fonti as fonti

  # Crea o merge ModalitaGiuridica
  modalita: |
    MERGE (m:ModalitaGiuridica {node_id: $node_id})
    ON CREATE SET
      m.nome = $nome,
      m.nome_normalizzato = $nome_normalizzato,
      m.descrizione = $descrizione,
      m.tipo_modalita = $tipo_modalita,
      m.correlativo = $correlativo,
      m.fonti = [$fonte],
      m.schema_version = $schema_version,
      m.created_at = datetime()
    ON MATCH SET
      m.fonti = CASE WHEN $fonte IN m.fonti THEN m.fonti ELSE m.fonti + $fonte END,
      m.updated_at = datetime()
    RETURN m.node_id as node_id, m.fonti as fonti

  # ─────────────────────────────────────────────────────────────────────────
  # FATTI E ATTI (priorità 3)
  # ─────────────────────────────────────────────────────────────────────────

  # Crea o merge FattoGiuridico
  fatto: |
    MERGE (f:FattoGiuridico {node_id: $node_id})
    ON CREATE SET
      f.nome = $nome,
      f.nome_normalizzato = $nome_normalizzato,
      f.descrizione = $descrizione,
      f.tipo_fatto = $tipo_fatto,
      f.effetti = $effetti,
      f.fonti = [$fonte],
      f.schema_version = $schema_version,
      f.created_at = datetime()
    ON MATCH SET
      f.fonti = CASE WHEN $fonte IN f.fonti THEN f.fonti ELSE f.fonti + $fonte END,
      f.updated_at = datetime()
    RETURN f.node_id as node_id, f.fonti as fonti

  # Crea o merge AttoGiuridico (entità, non sentenza)
  atto: |
    MERGE (a:AttoGiuridicoEntita {node_id: $node_id})
    ON CREATE SET
      a.nome = $nome,
      a.nome_normalizzato = $nome_normalizzato,
      a.descrizione = $descrizione,
      a.tipo_atto = $tipo_atto,
      a.forma = $forma,
      a.fonti = [$fonte],
      a.schema_version = $schema_version,
      a.created_at = datetime()
    ON MATCH SET
      a.fonti = CASE WHEN $fonte IN a.fonti THEN a.fonti ELSE a.fonti + $fonte END,
      a.updated_at = datetime()
    RETURN a.node_id as node_id, a.fonti as fonti

  # Crea o merge Procedura
  procedura: |
    MERGE (p:Procedura {node_id: $node_id})
    ON CREATE SET
      p.nome = $nome,
      p.nome_normalizzato = $nome_normalizzato,
      p.descrizione = $descrizione,
      p.tipo_procedura = $tipo_procedura,
      p.fasi = $fasi,
      p.fonti = [$fonte],
      p.schema_version = $schema_version,
      p.created_at = datetime()
    ON MATCH SET
      p.fonti = CASE WHEN $fonte IN p.fonti THEN p.fonti ELSE p.fonti + $fonte END,
      p.updated_at = datetime()
    RETURN p.node_id as node_id, p.fonti as fonti

  # Crea o merge Termine
  termine: |
    MERGE (t:Termine {node_id: $node_id})
    ON CREATE SET
      t.nome = $nome,
      t.nome_normalizzato = $nome_normalizzato,
      t.descrizione = $descrizione,
      t.tipo_termine = $tipo_termine,
      t.durata = $durata,
      t.decorrenza = $decorrenza,
      t.fonti = [$fonte],
      t.schema_version = $schema_version,
      t.created_at = datetime()
    ON MATCH SET
      t.fonti = CASE WHEN $fonte IN t.fonti THEN t.fonti ELSE t.fonti + $fonte END,
      t.updated_at = datetime()
    RETURN t.node_id as node_id, t.fonti as fonti

  # Crea o merge EffettoGiuridico
  effetto: |
    MERGE (e:EffettoGiuridico {node_id: $node_id})
    ON CREATE SET
      e.nome = $nome,
      e.nome_normalizzato = $nome_normalizzato,
      e.descrizione = $descrizione,
      e.tipo_effetto = $tipo_effetto,
      e.fonti = [$fonte],
      e.schema_version = $schema_version,
      e.created_at = datetime()
    ON MATCH SET
      e.fonti = CASE WHEN $fonte IN e.fonti THEN e.fonti ELSE e.fonti + $fonte END,
      e.updated_at = datetime()
    RETURN e.node_id as node_id, e.fonti as fonti

  # Crea o merge Responsabilita
  responsabilita: |
    MERGE (r:Responsabilita {node_id: $node_id})
    ON CREATE SET
      r.nome = $nome,
      r.nome_normalizzato = $nome_normalizzato,
      r.descrizione = $descrizione,
      r.tipo_responsabilita = $tipo_responsabilita,
      r.fonti = [$fonte],
      r.schema_version = $schema_version,
      r.created_at = datetime()
    ON MATCH SET
      r.fonti = CASE WHEN $fonte IN r.fonti THEN r.fonti ELSE r.fonti + $fonte END,
      r.updated_at = datetime()
    RETURN r.node_id as node_id, r.fonti as fonti

  # Crea o merge Rimedio
  rimedio: |
    MERGE (r:Rimedio {node_id: $node_id})
    ON CREATE SET
      r.nome = $nome,
      r.nome_normalizzato = $nome_normalizzato,
      r.descrizione = $descrizione,
      r.tipo_rimedio = $tipo_rimedio,
      r.fonti = [$fonte],
      r.schema_version = $schema_version,
      r.created_at = datetime()
    ON MATCH SET
      r.fonti = CASE WHEN $fonte IN r.fonti THEN r.fonti ELSE r.fonti + $fonte END,
      r.updated_at = datetime()
    RETURN r.node_id as node_id, r.fonti as fonti

  # ─────────────────────────────────────────────────────────────────────────
  # AVANZATE (priorità 4)
  # ─────────────────────────────────────────────────────────────────────────

  # Crea o merge Sanzione
  sanzione: |
    MERGE (s:Sanzione {node_id: $node_id})
    ON CREATE SET
      s.nome = $nome,
      s.nome_normalizzato = $nome_normalizzato,
      s.descrizione = $descrizione,
      s.tipo_sanzione = $tipo_sanzione,
      s.fonti = [$fonte],
      s.schema_version = $schema_version,
      s.created_at = datetime()
    ON MATCH SET
      s.fonti = CASE WHEN $fonte IN s.fonti THEN s.fonti ELSE s.fonti + $fonte END,
      s.updated_at = datetime()
    RETURN s.node_id as node_id, s.fonti as fonti

  # Crea o merge Caso
  caso: |
    MERGE (c:Caso {node_id: $node_id})
    ON CREATE SET
      c.nome = $nome,
      c.nome_normalizzato = $nome_normalizzato,
      c.descrizione = $descrizione,
      c.esito = $esito,
      c.principi_applicati = $principi_applicati,
      c.fonti = [$fonte],
      c.schema_version = $schema_version,
      c.created_at = datetime()
    ON MATCH SET
      c.fonti = CASE WHEN $fonte IN c.fonti THEN c.fonti ELSE c.fonti + $fonte END,
      c.updated_at = datetime()
    RETURN c.node_id as node_id, c.fonti as fonti

  # Crea o merge Eccezione
  eccezione: |
    MERGE (e:Eccezione {node_id: $node_id})
    ON CREATE SET
      e.nome = $nome,
      e.nome_normalizzato = $nome_normalizzato,
      e.descrizione = $descrizione,
      e.regola_generale = $regola_generale,
      e.fonti = [$fonte],
      e.schema_version = $schema_version,
      e.created_at = datetime()
    ON MATCH SET
      e.fonti = CASE WHEN $fonte IN e.fonti THEN e.fonti ELSE e.fonti + $fonte END,
      e.updated_at = datetime()
    RETURN e.node_id as node_id, e.fonti as fonti

  # Crea o merge Clausola
  clausola: |
    MERGE (c:Clausola {node_id: $node_id})
    ON CREATE SET
      c.nome = $nome,
      c.nome_normalizzato = $nome_normalizzato,
      c.descrizione = $descrizione,
      c.tipo_clausola = $tipo_clausola,
      c.fonti = [$fonte],
      c.schema_version = $schema_version,
      c.created_at = datetime()
    ON MATCH SET
      c.fonti = CASE WHEN $fonte IN c.fonti THEN c.fonti ELSE c.fonti + $fonte END,
      c.updated_at = datetime()
    RETURN c.node_id as node_id, c.fonti as fonti

# Query Cypher per creazione relazioni
cypher_relations:
  # Norma → Concetto (DISCIPLINA)
  norma_disciplina_concetto: |
    MATCH (n:Norma {URN: $urn})
    MATCH (c:ConcettoGiuridico {node_id: $concept_id})
    MERGE (n)-[r:DISCIPLINA]->(c)
    ON CREATE SET r.created_at = datetime(), r.fonte = $fonte
    RETURN type(r) as rel_type

  # Norma → Principio (ESPRIME_PRINCIPIO)
  norma_esprime_principio: |
    MATCH (n:Norma {URN: $urn})
    MATCH (p:PrincipioGiuridico {node_id: $principle_id})
    MERGE (n)-[r:ESPRIME_PRINCIPIO]->(p)
    ON CREATE SET r.created_at = datetime(), r.fonte = $fonte
    RETURN type(r) as rel_type

  # Norma → Definizione (DEFINISCE)
  norma_definisce: |
    MATCH (n:Norma {URN: $urn})
    MATCH (d:DefinizioneLegale {node_id: $definition_id})
    MERGE (n)-[r:DEFINISCE]->(d)
    ON CREATE SET r.created_at = datetime(), r.fonte = $fonte
    RETURN type(r) as rel_type

  # Dottrina → Norma (COMMENTA)
  dottrina_commenta_norma: |
    MATCH (d:Dottrina {node_id: $dottrina_id})
    MATCH (n:Norma {URN: $urn})
    MERGE (d)-[r:COMMENTA]->(n)
    ON CREATE SET r.created_at = datetime()
    RETURN type(r) as rel_type

  # Dottrina → Concetto (SPIEGA)
  dottrina_spiega_concetto: |
    MATCH (d:Dottrina {node_id: $dottrina_id})
    MATCH (c:ConcettoGiuridico {node_id: $concept_id})
    MERGE (d)-[r:SPIEGA]->(c)
    ON CREATE SET r.created_at = datetime()
    RETURN type(r) as rel_type

  # Concetto → Concetto (SPECIES - sottotipo)
  concetto_species: |
    MATCH (c1:ConcettoGiuridico {node_id: $parent_id})
    MATCH (c2:ConcettoGiuridico {node_id: $child_id})
    MERGE (c2)-[r:SPECIES]->(c1)
    ON CREATE SET r.created_at = datetime(), r.fonte = $fonte
    RETURN type(r) as rel_type

  # Principio ↔ Principio (BILANCIA_CON)
  principio_bilancia: |
    MATCH (p1:PrincipioGiuridico {node_id: $principle1_id})
    MATCH (p2:PrincipioGiuridico {node_id: $principle2_id})
    MERGE (p1)-[r:BILANCIA_CON]->(p2)
    ON CREATE SET r.created_at = datetime(), r.fonte = $fonte
    RETURN type(r) as rel_type

# Indici da creare per performance
indexes:
  # Core (priorità 1)
  - label: ConcettoGiuridico
    property: node_id
    type: unique
  - label: ConcettoGiuridico
    property: nome_normalizzato
    type: index
  - label: PrincipioGiuridico
    property: node_id
    type: unique
  - label: PrincipioGiuridico
    property: nome_normalizzato
    type: index
  - label: DefinizioneLegale
    property: node_id
    type: unique
  - label: DefinizioneLegale
    property: nome_normalizzato
    type: index

  # Soggetti (priorità 2)
  - label: SoggettoGiuridico
    property: node_id
    type: unique
  - label: SoggettoGiuridico
    property: nome_normalizzato
    type: index
  - label: Ruolo
    property: node_id
    type: unique
  - label: Ruolo
    property: nome_normalizzato
    type: index
  - label: ModalitaGiuridica
    property: node_id
    type: unique
  - label: ModalitaGiuridica
    property: nome_normalizzato
    type: index

  # Fatti e atti (priorità 3)
  - label: FattoGiuridico
    property: node_id
    type: unique
  - label: FattoGiuridico
    property: nome_normalizzato
    type: index
  - label: AttoGiuridicoEntita
    property: node_id
    type: unique
  - label: AttoGiuridicoEntita
    property: nome_normalizzato
    type: index
  - label: Procedura
    property: node_id
    type: unique
  - label: Procedura
    property: nome_normalizzato
    type: index
  - label: Termine
    property: node_id
    type: unique
  - label: Termine
    property: nome_normalizzato
    type: index
  - label: EffettoGiuridico
    property: node_id
    type: unique
  - label: EffettoGiuridico
    property: nome_normalizzato
    type: index
  - label: Responsabilita
    property: node_id
    type: unique
  - label: Responsabilita
    property: nome_normalizzato
    type: index
  - label: Rimedio
    property: node_id
    type: unique
  - label: Rimedio
    property: nome_normalizzato
    type: index

  # Avanzate (priorità 4)
  - label: Sanzione
    property: node_id
    type: unique
  - label: Sanzione
    property: nome_normalizzato
    type: index
  - label: Caso
    property: node_id
    type: unique
  - label: Caso
    property: nome_normalizzato
    type: index
  - label: Eccezione
    property: node_id
    type: unique
  - label: Eccezione
    property: nome_normalizzato
    type: index
  - label: Clausola
    property: node_id
    type: unique
  - label: Clausola
    property: nome_normalizzato
    type: index

# Cleanup query
cleanup:
  # Cancella tutti i nodi Dottrina esistenti (pre-enrichment)
  delete_old_dottrina: |
    MATCH (d:Dottrina)
    WHERE NOT exists(d.schema_version) OR d.schema_version < $min_version
    WITH d LIMIT $batch_size
    DETACH DELETE d
    RETURN count(d) as deleted
